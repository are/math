import '../common/reset.css'

import { run } from '../common/runtime.js'
import { responsiveCanvasHook } from '../common/canvas.js'

import anime from 'animejs'

function makePoint(o) {
  return { opacity: 0, textOpacity: 0, ...o }
}

function generateArray(length, fn) {
  return Array.from({ length }, (_, i) => fn(i))
}

function drawBackground(ctx) {
  ctx.fillStyle = 'black'
  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
}

function drawNumberLine(ctx, { scale, width }) {
  const centerX = ctx.canvas.width / 2
  const centerY = ctx.canvas.height / 2

  const stretch = scale * (ctx.canvas.width / 2)

  ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + scale / 2})`
  ctx.fillRect(centerX - stretch, centerY - width / 2, stretch * 2, width)
}

function drawPoints(ctx, points) {
  const centerY = ctx.canvas.height / 2
  const spaceBetween = ctx.canvas.width / points.length
  const pointWidth = 4
  const pointHeight = 20

  for (const [i, { opacity, textOpacity }] of points.entries()) {
    const positionX = spaceBetween * i + spaceBetween / 2

    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`
    ctx.fillRect(
      positionX - pointWidth / 2,
      centerY - pointHeight / 2,
      pointWidth,
      pointHeight
    )

    ctx.font = 'bold 22px Georgia'
    ctx.textAlign = 'center'
    ctx.fillStyle = `rgba(255, 255, 255, ${textOpacity})`
    ctx.fillText(`${i}`, positionX, centerY + 40)
  }
}

function lerpf(v0, v1, t) {
  return v0 * (1 - t) + v1 * t
}

function drawSegment(ctx, { xPoints, len, x, xLabel, segment }) {
  const spaceBetween = ctx.canvas.width / len
  const centerY = ctx.canvas.height / 2
  const segmentWidth = 4
  const pointWidth = 4
  const pointHeight = 40

  for (let [
    i,
    { opacity, textOpacity, value, lerp, segment },
  ] of xPoints.entries()) {
    const xStart =
      (value - x) * spaceBetween + (spaceBetween / 2 - segmentWidth / 2)

    const xPosition =
      value * spaceBetween + (spaceBetween / 2 - segmentWidth / 2)
    const flooredXPosition =
      lerpf(value, Math.floor(value), lerp) * spaceBetween +
      (spaceBetween / 2 - segmentWidth / 2)

    ctx.fillStyle = `rgba(255, 223, 0, ${segment})`
    ctx.font = 'bold 22px Georgia'

    ctx.fillText(
      xLabel,
      xStart + (spaceBetween * x * segment + segmentWidth) / 2,
      centerY - segmentWidth / 2 - 40
    )

    ctx.fillRect(
      xStart,
      centerY - segmentWidth / 2 - 20,
      spaceBetween * x * segment + segmentWidth / 2,
      segmentWidth
    )

    ctx.fillStyle = `rgba(255, 223, 0, ${opacity})`

    ctx.fillRect(
      flooredXPosition,
      centerY - pointHeight / 2,
      pointWidth,
      pointHeight
    )
  }
}

function drawTitle(ctx, { opacity, text }) {
  ctx.fillStyle = `rgba(255, 223, 0, ${opacity})`

  ctx.font = '42px Georgia'
  ctx.fillText(text, ctx.canvas.width / 2, 200)
}

function draw(ctx, state) {
  drawBackground(ctx)
  drawNumberLine(ctx, state.numberLine)
  drawPoints(ctx, state.points)
  drawSegment(ctx, state)
  drawTitle(ctx, state.title)
}

run(async function main() {
  const canvas = document.getElementById('app')
  const ctx = canvas.getContext('2d')

  const x = (1 + Math.sqrt(5)) / 2
  const len = 25

  const state = {
    len: len,
    numberLine: { scale: 0, width: 4 },
    points: generateArray(len, (i) => makePoint({ value: i })),
    x: x,
    xLabel: 'Ï†',
    xPoints: generateArray(len / 1.5, (i) =>
      makePoint({ value: (i + 1) * x, lerp: 0, segment: 0 })
    ),
    title: { opacity: 0, text: 'Beatty sequence (generated by Ï†)' },
  }

  const timeline = anime.timeline({
    update: () => draw(ctx, state),
  })

  timeline.add({
    targets: state.title,

    opacity: 1,

    easing: 'linear',
    duration: 3000,
  })

  timeline.add({
    targets: state.numberLine,

    scale: 1,

    easing: 'easeInQuint',
    duration: 1000,
  })

  timeline.add({
    targets: state.points,

    opacity: 1,

    easing: 'linear',
    duration: 1000,
    delay: anime.stagger(100, { from: 'center' }),
  })

  timeline.add({
    targets: state.points,

    textOpacity: 1,

    easing: 'linear',
    duration: 1000,
    delay: anime.stagger(50, { from: 'first' }),
  })

  for (let [i, point] of state.xPoints.entries()) {
    timeline.add({
      targets: state.xPoints[i],

      segment: 1,

      easing: 'easeInOutQuad',
      duration: 250,
    })

    timeline.add({
      targets: state.xPoints[i],

      opacity: 1,

      easing: 'easeInOutQuad',
      duration: 250,
    })
  }

  timeline.add({
    targets: state.xPoints,

    segment: 0,

    easing: 'easeInOutQuad',
    duration: 500,
  })

  for (let [i, point] of state.xPoints.entries()) {
    timeline.add({
      targets: state.xPoints[i],

      lerp: 1,

      easing: 'easeInOutQuad',
      duration: 500,
    })
  }

  // timeline.add({
  //   targets: state.segment,

  //   opacity: 1,

  //   easing: 'easeInOutQuad',
  //   duration: 500,
  // })

  responsiveCanvasHook(canvas, () => draw(ctx, state))
})
